package main

import (
	"context"
	"fmt"
	"log"
	"os"
	"strconv"
	"strings"
	"time"

	"github.com/gocql/gocql"
	_ "github.com/joho/godotenv/autoload"
)

// Service defines the interface for health checks.
type Service interface {
	Health() map[string]string
	Close() error
}

// service implements the Service interface.
type service struct {
	Session *gocql.Session
}

// Environment variables for ScyllaDB connection.
var (
	hosts                = os.Getenv("DB_HOSTS")       // Comma-separated list of hosts:port
	username             = os.Getenv("DB_USERNAME")    // Username for authentication
	password             = os.Getenv("DB_PASSWORD")    // Password for authentication
	keyspace             = os.Getenv("DB_KEYSPACE")    // Keyspace to connect to
	consistencyLevel     = os.Getenv("DB_CONSISTENCY") // Consistency level (optional)
	numbersOfConnections = os.Getenv("DB_CONNECTIONS") // Number of connections (optional)
)

// New initializes a new Service with a ScyllaDB Session.
func New() Service {
	cluster := gocql.NewCluster(parseHosts(hosts)...)
	cluster.PoolConfig.HostSelectionPolicy = gocql.TokenAwareHostPolicy(gocql.RoundRobinHostPolicy())

	// Set authentication if provided
	if username != "" && password != "" {
		cluster.Authenticator = gocql.PasswordAuthenticator{
			Username: username,
			Password: password,
		}
	}

	// Set keyspace
	if keyspace != "" {
		cluster.Keyspace = keyspace
	}

	// Set consistency level if provided
	if consistencyLevel != "" {
		if cl, err := parseConsistency(consistencyLevel); err == nil {
			cluster.Consistency = cl
		} else {
			log.Printf("Invalid SCYLLA_DB_CONSISTENCY '%s', using default: %v", consistencyLevel, err)
		}
	}

	// Set number of connections
	numbersOfConnections, err := strconv.Atoi(numbersOfConnections)

	if err != nil {
		cluster.NumConns = 2
	} else {
		cluster.NumConns = numbersOfConnections
	}

	// Create Session
	session, err := cluster.CreateSession()
	if err != nil {
		log.Fatalf("Failed to connect to ScyllaDB cluster: %v", err)
	}

	s := &service{Session: session}
	return s
}

// parseHosts splits the comma-separated hosts string into a slice.
func parseHosts(hosts string) []string {
	return strings.Split(hosts, ",")
}

// parseConsistency converts a string to a gocql.Consistency value.
func parseConsistency(cons string) (gocql.Consistency, error) {
	switch strings.ToUpper(cons) {
	case "ANY":
		return gocql.Any, nil
	case "ONE":
		return gocql.One, nil
	case "TWO":
		return gocql.Two, nil
	case "THREE":
		return gocql.Three, nil
	case "QUORUM":
		return gocql.Quorum, nil
	case "ALL":
		return gocql.All, nil
	case "LOCAL_ONE":
		return gocql.LocalOne, nil
	case "LOCAL_QUORUM":
		return gocql.LocalQuorum, nil
	case "EACH_QUORUM":
		return gocql.EachQuorum, nil
	case "SERIAL":
		return gocql.Serial, nil
	case "LOCAL_SERIAL":
		return gocql.LocalSerial, nil
	default:
		return gocql.Quorum, fmt.Errorf("unknown consistency level: %s", cons)
	}
}

// Health returns the health status and statistics of the ScyllaDB cluster.
func (s *service) Health() map[string]string {
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	stats := make(map[string]string)

	// Check ScyllaDB health and populate the stats map
	stats = s.checkScyllaHealth(ctx, stats)

	return stats
}

// checkScyllaHealth checks the health of the ScyllaDB cluster and adds relevant statistics.
func (s *service) checkScyllaHealth(ctx context.Context, stats map[string]string) map[string]string {
	startedAt := time.Now()

	// Execute a simple query to check connectivity
	query := "SELECT now() FROM system.local"
	iter := s.Session.Query(query).WithContext(ctx).Iter()
	var currentTime time.Time
	if !iter.Scan(&currentTime) {
		if err := iter.Close(); err != nil {
			stats["status"] = "down"
			stats["message"] = fmt.Sprintf("Failed to execute query: %v", err)
			return stats
		}
	}
	if err := iter.Close(); err != nil {
		stats["status"] = "down"
		stats["message"] = fmt.Sprintf("Error during query execution: %v", err)
		return stats
	}

	// ScyllaDB is up
	stats["status"] = "up"
	stats["message"] = "It's healthy"
	stats["scylla_current_time"] = currentTime.String()

	// Retrieve cluster information
	// Get keyspace information
	getKeyspacesQuery := "SELECT keyspace_name FROM system_schema.keyspaces"
	keyspacesIterator := s.Session.Query(getKeyspacesQuery).Iter()

	stats["scylla_keyspaces"] = strconv.Itoa(keyspacesIterator.NumRows())
	if err := keyspacesIterator.Close(); err != nil {
		log.Fatalf("Failed to close keyspaces iterator: %v", err)
	}

	// Get cluster host information
	var currentDatacenter string
	clusterNodesIterator := s.Session.Query("SELECT data_center FROM system.peers").Iter()
	clusterNodesIterator.Scan(&currentDatacenter)

	// +1 is because the default connection (coordinator) is not included in the query
	stats["scylla_cluster_size"] = strconv.Itoa(clusterNodesIterator.NumRows() + 1)
	stats["scylla_current_datacenter"] = currentDatacenter
	if err := clusterNodesIterator.Close(); err != nil {
		log.Fatalf("Failed to close cluster nodes iterator: %v", err)
	}

	// Retrieve Connected Sessions
	connectedSessionsIterator := s.Session.Query("SELECT connection_stage as connected_sessions FROM system.clients").Iter()
	stats["scylla_active_conns"] = strconv.Itoa(connectedSessionsIterator.NumRows())

	if err := connectedSessionsIterator.Close(); err != nil {
		log.Fatalf("Failed to close cluster nodes iterator: %v", err)
	}

	// Calculate the time taken to perform the health check
	stats["scylla_health_check_duration"] = time.Since(startedAt).String()
	return stats
}

// Close gracefully closes the ScyllaDB Session.
func (s *service) Close() error {
	s.Session.Close()
	return nil
}
